// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  // output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =======================================================
// ChatOrbit Prisma Schema (ordered + normalized)
// =======================================================
// Table of contents
//  0) Global Enums
//  1) Core User & Access
//  2) Conversation & Participation
//  3) Messaging
//  4) Contacts, Reports, Auditing
//  5) Status / Stories
//  6) Bots & Automation
//  7) Calls
// =======================================================

// ===================== 0) Global Enums =====================

enum Plan {
  FREE
  PREMIUM
}

enum RoomRole {
  MEMBER
  MODERATOR
  ADMIN
}

enum AttachmentKind {
  IMAGE
  VIDEO
  AUDIO
  FILE
  STICKER
  GIF
}

enum StatusAudience {
  CONTACTS
  MUTUALS
  CUSTOM
}

enum StatusAssetKind {
  IMAGE
  VIDEO
  AUDIO
  GIF
  STICKER
  FILE
}

enum AutoResponderMode {
  OFF
  DM
  MENTION
  ALL
}

enum AutoTranslateMode {
  OFF
  TAGGED
  ALL
}

enum AIAssistantMode {
  OFF
  MENTION
  ALWAYS
}

enum ContentScope {
  COMMANDS
  MENTIONS
  ALL
}

// ✅ Calls

enum CallMode {
  AUDIO
  VIDEO
}

enum CallStatus {
  INITIATED
  RINGING
  ANSWERED
  REJECTED
  MISSED
  CANCELLED
  ENDED
}

// ===================== 1) Core User & Access =====================

model User {
  id                          Int     @id @default(autoincrement())
  username                    String  @unique
  email                       String? @unique
  password                    String
  phoneNumber                 String? @db.VarChar(32)
  preferredLanguage           String  @default("en")
  allowExplicitContent        Boolean @default(true)
  showOriginalWithTranslation Boolean @default(true)
  role                        String  @default("USER")
  enableAIResponder           Boolean @default(false)
  enableSmartReplies          Boolean @default(false)

  autoResponderMode        AutoResponderMode @default(DM)
  autoResponderCooldownSec Int               @default(120)
  autoResponderActiveUntil DateTime?
  autoResponderSignature   String?

  publicKey  String?
  privateKey String?

  // Relations
  messages              Message[]         @relation("UserMessages")
  participants          Participant[]
  reports               Report[]          @relation("UserReports")
  randomChatRooms       RandomChatRoom[]  @relation("RandomChatParticipants")
  readMessages          Message[]         @relation("ReadMessages")
  contactsOwned         Contact[]         @relation("ContactsOwned")
  contactsSaved         Contact[]         @relation("ContactsSaved")
  auditLogs             AuditLog[]        @relation("AuditActor")
  messageKeys           MessageKey[]
  devices               Device[]
  deviceRevocations     Device[]          @relation("DeviceRevokedBy")
  createdInvites        ChatRoomInvite[]  @relation("InviteCreator")
  messageReactions      MessageReaction[]
  statusesAuthored      Status[]
  statusKeys            StatusKey[]
  statusViews           StatusView[]
  statusReactions       StatusReaction[]
  botsOwned             Bot[]             @relation("BotsOwned")
  botsAsService         Bot[]             @relation("BotServiceUser")
  provisionLinks        ProvisionLink[]   @relation("ProvisionLinkUser")
  provisionLinksCreated ProvisionLink[]   @relation("ProvisionLinkCreator")

  // NEW/IMPORTANT: opposite sides
  callsPlaced                Call[]              @relation("CallCaller")
  callsReceived              Call[]              @relation("CallCallee")
  scheduledMessagesAuthored  ScheduledMessage[]  @relation("ScheduledMessageSender")
  messageSessionKeysReceived MessageSessionKey[] @relation("MsgSessionKeys_Recipient")

  // Settings
  plan              Plan    @default(FREE)
  autoDeleteSeconds Int?
  showReadReceipts  Boolean @default(true)
  avatarUrl         String?
  emojiTag          String?
  messageTone       String? @default("default.mp3")
  ringtone          String? @default("classic.mp3")
}

model Device {
  id String @id @default(cuid())

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  publicKey  String
  name       String?
  platform   String?
  isPrimary  Boolean   @default(false)
  createdAt  DateTime  @default(now())
  lastSeenAt DateTime?
  revokedAt  DateTime?

  revokedById Int?
  revokedBy   User? @relation("DeviceRevokedBy", fields: [revokedById], references: [id])

  // NEW: opposite side
  messageSessionKeys MessageSessionKey[] @relation("MsgSessionKeys_Device")

  @@index([userId])
}

model ProvisionLink {
  id String @id @default(cuid())

  // normalized to Int and related to User
  userId Int
  user   User @relation("ProvisionLinkUser", fields: [userId], references: [id], onDelete: Cascade)

  createdById Int
  createdBy   User @relation("ProvisionLinkCreator", fields: [createdById], references: [id], onDelete: SetNull)

  secret    String // random 32 bytes (base64)
  expiresAt DateTime
  usedAt    DateTime?
  sasCode   String // 6-digit code
  createdAt DateTime  @default(now())

  @@index([userId])
}

// ===================== 2) Conversation & Participation =====================

model ChatRoom {
  id              Int             @id @default(autoincrement())
  name            String?
  aiAssistantMode AIAssistantMode @default(OFF)
  isGroup         Boolean         @default(false)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  participants Participant[]
  messages     Message[]     @relation("ChatRoomMessages")

  autoTranslateMode AutoTranslateMode @default(OFF)
  allowOrbitBot     Boolean           @default(false)

  invites     ChatRoomInvite[] @relation("RoomInvites")
  botInstalls BotInstall[]     @relation("BotInstallRoom")

  // NEW: opposite side
  scheduledMessages ScheduledMessage[] @relation("ScheduledMessageRoom")

  @@index([updatedAt, id], map: "room_updated_id")
}

model Participant {
  id         Int @id @default(autoincrement())
  userId     Int
  chatRoomId Int

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)

  role       RoomRole @default(MEMBER)
  joinedAt   DateTime @default(now())
  allowAIBot Boolean  @default(true)

  @@unique([userId, chatRoomId])
  @@index([chatRoomId], map: "part_room")
}

model ChatRoomInvite {
  id   Int    @id @default(autoincrement())
  code String @unique

  chatRoomId Int
  chatRoom   ChatRoom @relation("RoomInvites", fields: [chatRoomId], references: [id], onDelete: Cascade)

  createdById Int
  createdBy   User @relation("InviteCreator", fields: [createdById], references: [id], onDelete: Cascade)

  maxUses   Int       @default(0) // 0 = unlimited
  uses      Int       @default(0)
  expiresAt DateTime?
  createdAt DateTime  @default(now())
}

model RandomChatRoom {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  participants User[]    @relation("RandomChatParticipants")
  messages     Message[]
  aiEnabled    Boolean   @default(false)
}

// ===================== 3) Messaging =====================

model Message {
  id                Int       @id @default(autoincrement())
  contentCiphertext String
  rawContent        String
  translations      Json?
  translatedFrom    String?
  isExplicit        Boolean   @default(false)
  imageUrl          String?
  audioUrl          String?
  audioDurationSec  Int?
  expiresAt         DateTime?
  deletedBySender   Boolean   @default(false)

  senderId   Int
  chatRoomId Int

  sender   User     @relation("UserMessages", fields: [senderId], references: [id], onDelete: Cascade)
  chatRoom ChatRoom @relation("ChatRoomMessages", fields: [chatRoomId], references: [id], onDelete: Cascade)

  keys        MessageKey[]
  attachments MessageAttachment[]
  reactions   MessageReaction[]
  reports     Report[]

  randomChatRoomId Int?
  randomChatRoom   RandomChatRoom? @relation(fields: [randomChatRoomId], references: [id])

  createdAt   DateTime @default(now())
  readBy      User[]   @relation("ReadMessages")
  isAutoReply Boolean  @default(false)

  // NEW: opposite side
  sessionKeys MessageSessionKey[] @relation("MsgSessionKeys_Message")

  @@index([expiresAt])
  @@index([chatRoomId, id], map: "msg_room_id")
  @@index([chatRoomId, createdAt], map: "msg_room_time")
}

model MessageSessionKey {
  id String @id @default(cuid())

  messageId         Int
  recipientUserId   Int
  recipientDeviceId String

  // NAMED relations match the opposites we added:
  message         Message @relation("MsgSessionKeys_Message", fields: [messageId], references: [id], onDelete: Cascade)
  recipientUser   User    @relation("MsgSessionKeys_Recipient", fields: [recipientUserId], references: [id], onDelete: Cascade)
  recipientDevice Device  @relation("MsgSessionKeys_Device", fields: [recipientDeviceId], references: [id], onDelete: Cascade)

  encryptedSessionKey String

  @@index([messageId])
  @@index([recipientUserId])
  @@index([recipientDeviceId])
}

model MessageKey {
  messageId    Int
  userId       Int
  encryptedKey String

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId])
  @@index([userId])
}

model MessageAttachment {
  id          Int            @id @default(autoincrement())
  messageId   Int
  kind        AttachmentKind
  url         String
  mimeType    String
  width       Int?
  height      Int?
  durationSec Int?
  caption     String?
  createdAt   DateTime       @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
}

model MessageReaction {
  messageId Int
  userId    Int
  emoji     String
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
}

model ScheduledMessage {
  id          Int      @id @default(autoincrement())
  chatRoomId  Int
  senderId    Int
  content     String
  scheduledAt DateTime
  createdAt   DateTime @default(now())

  // NAMED to match opposites in ChatRoom and User
  chatRoom ChatRoom @relation("ScheduledMessageRoom", fields: [chatRoomId], references: [id], onDelete: Cascade)
  sender   User     @relation("ScheduledMessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([chatRoomId])
  @@index([senderId])
}

// ========== 4) Contacts, Reports, Auditing ==========

model Contact {
  id Int @id @default(autoincrement())

  ownerId Int
  owner   User @relation("ContactsOwned", fields: [ownerId], references: [id], onDelete: Cascade)

  userId Int?
  user   User? @relation("ContactsSaved", fields: [userId], references: [id], onDelete: SetNull)

  externalPhone String? @db.VarChar(32)
  externalName  String?

  alias     String?
  favorite  Boolean  @default(false)
  createdAt DateTime @default(now())

  @@unique([ownerId, userId])
  @@unique([ownerId, externalPhone])
  @@index([ownerId])
  @@index([userId])
}

model Report {
  id               Int      @id @default(autoincrement())
  messageId        Int
  reporterId       Int
  decryptedContent String
  createdAt        DateTime @default(now())

  status     String    @default("OPEN") // "OPEN" | "RESOLVED" | "ACTIONED"
  resolvedAt DateTime?
  notes      String?

  message  Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  reporter User    @relation("UserReports", fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
}

model AuditLog {
  id      Int  @id @default(autoincrement())
  actorId Int
  actor   User @relation("AuditActor", fields: [actorId], references: [id], onDelete: Cascade)

  action     String // e.g., "users.list", "users.ban", "messages.delete"
  resource   String? // e.g., "user", "message", "chatroom"
  resourceId String? // string so we can store UUIDs or composite keys
  status     Int // HTTP status code of the request when logged
  ip         String?
  userAgent  String?
  metadata   Json? // optional redacted/structured context
  createdAt  DateTime @default(now())

  @@index([actorId, createdAt])
  @@index([action, createdAt])
}

// ===================== 5) Status / Stories =====================

model Status {
  id                Int            @id @default(autoincrement())
  authorId          Int
  author            User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  captionCiphertext String?
  encryptedKeys     Json?
  translatedFrom    String?
  translations      Json?
  isExplicit        Boolean        @default(false)
  audience          StatusAudience @default(MUTUALS)
  expiresAt         DateTime
  createdAt         DateTime       @default(now())

  assets    StatusAsset[]
  keys      StatusKey[]
  views     StatusView[]
  reactions StatusReaction[]

  @@index([authorId, expiresAt])
}

model StatusAsset {
  id          Int             @id @default(autoincrement())
  statusId    Int
  status      Status          @relation(fields: [statusId], references: [id], onDelete: Cascade)
  kind        StatusAssetKind
  url         String
  mimeType    String
  width       Int?
  height      Int?
  durationSec Int?
  caption     String?
  createdAt   DateTime        @default(now())

  @@index([statusId])
}

model StatusKey {
  statusId     Int
  userId       Int
  encryptedKey String

  status Status @relation(fields: [statusId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([statusId, userId])
}

model StatusView {
  id       Int      @id @default(autoincrement())
  statusId Int
  viewerId Int
  viewedAt DateTime @default(now())

  status Status @relation(fields: [statusId], references: [id], onDelete: Cascade)
  viewer User   @relation(fields: [viewerId], references: [id], onDelete: Cascade)

  @@unique([statusId, viewerId])
  @@index([viewerId])
}

model StatusReaction {
  statusId Int
  userId   Int
  emoji    String

  status Status @relation(fields: [statusId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([statusId, userId, emoji])
  @@index([statusId, emoji], map: "status_emoji")
}

// ===================== 6) Bots & Automation =====================

model Bot {
  id      Int  @id @default(autoincrement())
  ownerId Int
  owner   User @relation("BotsOwned", fields: [ownerId], references: [id], onDelete: Cascade)

  name   String
  url    String
  secret String

  serviceUserId Int?
  serviceUser   User? @relation("BotServiceUser", fields: [serviceUserId], references: [id], onDelete: SetNull)

  installs  BotInstall[]
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  @@unique([ownerId, name])
}

model BotInstall {
  id           Int          @id @default(autoincrement())
  botId        Int
  chatRoomId   Int
  contentScope ContentScope @default(COMMANDS)
  isEnabled    Boolean      @default(true)
  scopes       String?

  bot      Bot      @relation(fields: [botId], references: [id], onDelete: Cascade)
  chatRoom ChatRoom @relation("BotInstallRoom", fields: [chatRoomId], references: [id], onDelete: Cascade)

  events    BotEventLog[]
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  @@unique([botId, chatRoomId])
}

model BotEventLog {
  id            Int       @id @default(autoincrement())
  installId     Int
  eventId       String    @unique @default(cuid())
  type          String
  payload       Json
  status        String    @default("pending") // pending|delivered|failed
  attempts      Int       @default(0)
  nextAttemptAt DateTime?
  lastError     String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  install BotInstall @relation(fields: [installId], references: [id], onDelete: Cascade)

  @@index([installId])
}

// ===================== 7) Calls =====================

// ✅ Updated Call model per your spec: named relations, default status, and indexes
model Call {
  id         String     @id @default(uuid())
  callerId   Int
  calleeId   Int
  chatId     Int?
  mode       CallMode
  status     CallStatus @default(INITIATED)
  createdAt  DateTime   @default(now())
  acceptedAt DateTime?
  endedAt    DateTime?

  caller User @relation("CallCaller", fields: [callerId], references: [id])
  callee User @relation("CallCallee", fields: [calleeId], references: [id])

  @@index([callerId])
  @@index([calleeId])
  @@index([createdAt])
}
